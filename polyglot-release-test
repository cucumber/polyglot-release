#!/bin/bash

FAILURE=
SRC=$(realpath .)
GNUPGHOME=$(mktemp -d)

function import_gpg_key() {
  gpg --homedir=$GNUPGHOME --batch -q --fast-import "$SRC/tests/gpg-key.private.pgp"
  GPG_KEY_ID=D8C4AB54E1AB7D53
}

function setup_git_repos() {
  fixture=$1
  mkdir origin
  pushd origin > /dev/null
  git init --quiet --bare
  git symbolic-ref HEAD refs/heads/main
  popd > /dev/null
  git clone origin local --quiet 2> /dev/null
  pushd local > /dev/null
  git checkout --quiet -b main
  git config user.email "tests@example.com"
  git config user.name "Cucumber tests"
  git config user.signingkey $GPG_KEY_ID
  cp -R $fixture/. . 
  git add .
  git commit --message "Initial commit" --quiet
  git tag v0.0.1
  git push --set-upstream origin main --quiet
  git push --tags --quiet
  popd > /dev/null
}

function get_fixture() {
  test=$1
  header="$(head -n 1 $test)"
  fixture_pattern="# fixture: (.+)"
  if [[ $header =~ $fixture_pattern ]]
  then
    fixture="${BASH_REMATCH[1]}"
  else
    fixture=polyglot
  fi
  echo $fixture
}

function setup_workdir() {
  workdir=$1
  fixture=$2
  pushd $workdir > /dev/null
  setup_git_repos $fixture
  popd > /dev/null
  mkdir $workdir/bin
  for tool in gpg git mvn npm changelog realpath node; do
    cat << EOF > $workdir/bin/$tool
#!/bin/sh
$(which $tool) "\$@"
EOF
    chmod +x $workdir/bin/$tool
  done
}

function manual_test() {
  fixture=$1
  workdir=$(mktemp -d)
  import_gpg_key
  setup_workdir $workdir $fixture
  pushd $workdir/local > /dev/null
  PATH=$workdir/bin:/bin:/usr/bin:$SRC \
    RELEASE_DATE=2000-01-01 \
    GIT_CONFIG_GLOBAL=/dev/null \
    GNUPGHOME=$GNUPGHOME \
    /bin/bash
  popd > /dev/null
}

function run_test() {
  test=$1
  test_failed=
  echo -n "${test##*/} "
  workdir=$(mktemp -d)
  fixture=$(realpath ./tests/fixtures/$(get_fixture $test))
  import_gpg_key
  setup_workdir $workdir $fixture
  pushd $workdir/local > /dev/null
  PATH=$workdir/bin:/bin:/usr/bin:$SRC \
    RELEASE_DATE=2000-01-01 \
    GIT_CONFIG_GLOBAL=/dev/null \
    GNUPGHOME=$GNUPGHOME \
    /bin/bash $test \
    > $test.actual.output \
    2> $test.actual.stderr
  echo $? > $test.actual.exit-status
  git diff --unified=0 \
    | sed -e '/^index/d' \
    > $test.actual.git-diff
  git log --format="%s %d" \
    > $test.actual.git-log
  popd > /dev/null
  pushd $workdir/origin > /dev/null
  GNUPGHOME=$GNUPGHOME \
    git log \
    --format="%s %d %GS" \
    > $test.actual.origin-git-log
  popd > /dev/null
  for type in output git-diff git-log exit-status stderr origin-git-log; do
    if [ -f "$test.expected.$type" ]; then
      failure=$(diff $test.expected.$type $test.actual.$type)
      if [[ $? != 0 ]]; then 
        if [ -z $test_failed ]; then
          echo " ðŸ”´"
        fi
        echo
        echo Actual $type output different to expected!
        echo
        echo $(realpath --relative-to="$SRC" "$test.expected.$type")
        echo $(realpath --relative-to="$SRC" "$test.actual.$type")
        echo
        echo "$failure"
        test_failed="true";
      fi
    fi
  done
  if [ -n "$test_failed" ]; then
    FAILURE="true"
    echo
    echo "Working directory: $workdir"
    echo "GNUPGHOME: $GNUPGHOME"
    echo 
  else
    echo âœ…
  fi
}


if [ $1 ]; then
  if [[ $1 =~ tests/.*\.sh$ ]]; then
    # Run a single test
    run_test $(realpath $1)
  fi
  if [[ $1 =~ fixtures/ ]]; then
    # Start a manual test session
    manual_test $(realpath $1)
  fi
else
  # Run all tests
  tests=$(realpath tests)
  for test in $tests/*.sh; do
    run_test $test
  done
fi
test -z $FAILURE

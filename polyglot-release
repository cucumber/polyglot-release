#!/bin/bash
set -e

# quiet output from pushd / popd / find
function pushd() {
  command pushd "$@" >/dev/null
}
function popd() {
  command popd >/dev/null
}
function find() {
  command find "$@" 2>/dev/null
}
# Usage: 'run pre_release|release|post_release <language>'
function run() {
  if [[ -d $2 ]]; then
    pushd "$2"
    eval "$1_$2"
    popd
  elif eval "is_monoglot_$2"; then
    eval "$1_$2"
  fi
}
SUPPORTED_LANGUAGES=()

SUPPORTED_LANGUAGES+=("dotnet")
function is_monoglot_dotnet() {
  [[ $(find ./*.sln -type f | wc -l) -gt 0 ]]
}
function pre_release_dotnet() {
  check_for_tools "xmlstarlet"
  if [[ ! -f "$(cs_project_file)" ]]; then
    echo "This looks like a .Net project, but there is no $(cs_project_file) file"
    exit 1
  fi
}
function release_dotnet() {
  xmlstarlet ed --pf --omit-decl --inplace --update /Project/PropertyGroup/VersionNumber --value "$NEW_VERSION" "$(cs_project_file)"
}
function post_release_dotnet() {
  # noop
  :
}
function cs_project_file() {
  solution_file=$(realpath "$(find ./*.sln -type f)" --relative-to "$(pwd)")
  project_name=${solution_file%.sln}
  echo "$project_name/$project_name.csproj"
}

SUPPORTED_LANGUAGES+=("github-action")
function is_monoglot_github-action() {
  [[ -f action.yaml ]]
}
function pre_release_github-action() {
  # noop
  :
}
function release_github-action() {
  # noop, publishing github only uses git tags
  :
}
function post_release_github-action() {
  # noop
  :
}

SUPPORTED_LANGUAGES+=("go")
function is_monoglot_go() {
  [[ -f go.mod ]]
}
function pre_release_go() {
  check_for_tools "go" "jq" "sed"
}
function release_go() {
  MODULE_WITH_NEW_VERSION=$(
    go mod edit -json |\
    jq -r '.Module.Path' |\
    sed -E "s/(.*)v[0-9]+.[0-9]+.[0-9]+$/\1v$NEW_VERSION/"
  )
  go mod edit -module "$MODULE_WITH_NEW_VERSION"
}
function post_release_go() {
  # noop
  :
}

SUPPORTED_LANGUAGES+=("javascript")
function is_monoglot_javascript() {
  [[ -f package.json ]]
}
function pre_release_javascript() {
  check_for_tools "npm"
}
function release_javascript() {
  npm version --no-git-tag-version "$NEW_VERSION" >/dev/null
}
function post_release_javascript() {
  # noop
  :
}

SUPPORTED_LANGUAGES+=("java")
function is_monoglot_java() {
  [[ -f pom.xml ]]
}
function pre_release_java() {
  check_for_tools "mvn"
}
function release_java() {
  mvn --quiet versions:set -DnewVersion="$NEW_VERSION" 2>/dev/null
  mvn --quiet versions:set-scm-tag -DnewTag="v$NEW_VERSION" 2>/dev/null
}
function post_release_java() {
  new_version_template="\${parsedVersion.majorVersion}.\${parsedVersion.minorVersion}.\${parsedVersion.nextIncrementalVersion}-SNAPSHOT"
  mvn --quiet \
    build-helper:parse-version \
    versions:set -DnewVersion="$new_version_template" \
    versions:set-scm-tag -DnewTag="HEAD" \
    2>/dev/null
}

SUPPORTED_LANGUAGES+=("perl")
function is_monoglot_perl() {
  [[ -f cpanfile ]]
}
function pre_release_perl() {
  if [[ ! -f VERSION ]];
  then
    echo "This looks like a Perl project, but there is no VERSION file"
    exit 1
  fi
}
function release_perl() {
  echo "$NEW_VERSION" >VERSION
}
function post_release_perl() {
  # noop
  :
}

SUPPORTED_LANGUAGES+=("python")
function is_monoglot_python() {
  [[ -f pyproject.toml  || -f setup.py ]]
}
function pre_release_python() {
  check_for_tools "sed"
}
function release_python() {
  if  [[ -f pyproject.toml ]]; then
    PROJECT_FILE=pyproject.toml
  else
    PROJECT_FILE=setup.py
  fi

  sed -i \
  		-e "s/\(version *= *\"\)[0-9]*\.[0-9]*\.[0-9]*\(\"\)/\1$NEW_VERSION\2/" \
  		"$PROJECT_FILE"
}
function post_release_python() {
  # noop
  :
}

SUPPORTED_LANGUAGES+=("ruby")
function is_monoglot_ruby() {
  [[ $(find ./*.gemspec -type f | wc -l) -gt 0 ]]
}
function pre_release_ruby() {
  if [[ ! -f VERSION ]];
  then
    echo "This looks like a Ruby project, but there is no VERSION file"
    exit 1
  fi
}
function release_ruby() {
  echo "$NEW_VERSION" >VERSION
}
function post_release_ruby() {
  # noop
  :
}

function validate_new_version_argument() {
  if [[ ! "$NEW_VERSION" =~ ^[0-9]+.[0-9]+.[0-9]+$ ]]; then
    echo "Invalid MAJOR.MINOR.PATCH argument: $NEW_VERSION"
    show_usage
    exit 1
  fi

  if [ -n "$(git tag --list "v$NEW_VERSION")" ]; then
    echo "Version $NEW_VERSION has already been released."
    exit 1
  fi
}

function check_for_tools() {
  for tool in "$@"; do
    if ! command -v "$tool" >/dev/null; then
      echo "$tool is not installed!"
      missing_tool="true"
    fi
  done
  if [ -n "$missing_tool" ]; then
    echo
    echo "Please install the missing required tool(s)."
    exit 1
  fi
}

function check_changelog_exists() {
  if [[ ! -f CHANGELOG.md ]]; then
    echo "Please create a CHANGELOG.md"
    exit 1
  fi
}

function check_in_git_root_directory() {
  git_root=$(git rev-parse --show-toplevel)
  pwd=$(realpath "$(pwd)")
  if [[ "$git_root" != "$pwd" ]]; then
    relative_path=$(realpath --relative-to="$(pwd)" "$git_root")
    echo "You're not in the root directory of your git repo!"
    echo
    echo "Try this:"
    echo "    cd $relative_path"
    exit 1
  fi
}

function check_gpg_keys_configured() {
  if [[ ! $(git config user.signingkey) ]]; then
    echo "You do not have a user.signingkey configured in git!"
    echo
    echo "All commits need to be signed. Please see https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key"
    exit 1
  fi
  key=$(git config user.signingkey)
  if ! gpg --list-secret-keys | grep -q "$key"; then
    echo "Your git user.signingkey ($key) was not found in your GPG keys."
    echo
    echo "To see all your GPG keys, use:"
    echo "    gpg --list-secret-keys"
    echo
    echo "All commits need to be signed. Please see https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key"
    exit 1
  fi
}

function check_git_tags_fetched() {
  latest_version_from_changelog=$(changelog latest)
  if [[ $latest_version_from_changelog == v* ]]; then
    expected_tag="$latest_version_from_changelog"
  else
    expected_tag="v$latest_version_from_changelog"
  fi
  if [[ -z $(git tag --list "$expected_tag") ]]; then
    echo "No git tag found for $expected_tag (found in CHANGELOG.md)!"
    echo
    echo "Do you need to run this?"
    echo "    git fetch --tags"
    exit 1
  fi
}

function check_git_index_clean() {
  if ! git diff-index --quiet HEAD; then
    echo "Git has uncommitted changes."
    exit 1
  fi
}

function show_usage() {
  echo "Usage: polyglot-release [OPTIONS] MAJOR.MINOR.PATCH"
  echo "OPTIONS:"
  echo "  --help                 shows this help"
  echo "  --no-git-push          do not push to git"
  echo "  --quiet                don't log progress messages"
}

function log() {
  if [[ -z $QUIET ]]; then
    echo "$1"
  fi
}

function format_commit_message() {
  echo "$1

Created-by: polyglot-release v${POLYGLOT_RELEASE_VERSION:--unknown}"
}

# Initialize global variables
NEW_VERSION=
NO_GIT_PUSH=
QUIET=
POSITIONAL_ARGS=()
RELEASE_DATE=${RELEASE_DATE:-$(date +%F)}

while [[ $# -gt 0 ]]; do
  case $1 in
  --no-git-push)
    NO_GIT_PUSH="true"
    shift # past argument
    ;;
  --quiet)
    QUIET="true"
    shift # past argument
    ;;
  -h | --help)
    echo "Makes a release to GitHub"
    show_usage
    exit 0
    ;;
  --* | -*)
    echo "Unknown option $1"
    show_usage
    exit 1
    ;;
  *)
    POSITIONAL_ARGS+=("$1") # save positional arg
    shift                   # past argument
    ;;
  esac
done

set -- "${POSITIONAL_ARGS[@]}" # restore positional parameters

check_for_tools "git" "changelog" "gpg"
check_in_git_root_directory
check_changelog_exists
check_gpg_keys_configured
check_git_tags_fetched
check_git_index_clean

if [[ $# -ne 1 ]]; then
  echo "Please specify a version to release. Use --help to show usage instructions."
  echo
  echo "To help you choose the next version, here are the unreleased changes:"
  echo
  changelog show unreleased
  echo
  exit 1
fi
NEW_VERSION=$1
validate_new_version_argument

COMMIT_BEFORE_RELEASE="$(git rev-parse HEAD)"

###
## pre release
###
for language in "${SUPPORTED_LANGUAGES[@]}"; do
  run pre_release "$language"
done

###
## release
###
for language in "${SUPPORTED_LANGUAGES[@]}"; do
  run release "$language"
done

changelog release "$NEW_VERSION" \
  --release-date "$RELEASE_DATE" \
  --tag-format "v%s" \
  --output CHANGELOG.md

log "Package manager manifests and CHANGELOG.md updated for $NEW_VERSION"
log "Here's what changed:"
log "$(git -c color.diff=always diff)"

TAG="v$NEW_VERSION"
git commit --gpg-sign --quiet --all --message="$(format_commit_message "Prepare release $TAG")"
git tag --sign --message "$(format_commit_message "$TAG")" "$TAG"
log "Files committed to to git and tagged '$TAG'"

###
## post release
###
for language in "${SUPPORTED_LANGUAGES[@]}"; do
  run post_release "$language"
done

if [[ $(git status --porcelain) ]]; then
  git commit --gpg-sign --quiet --all --message="$(format_commit_message "Prepare for the next development iteration")"
  log "Post-release changes committed to to git"
fi

###
# push to github
##
local_branch=$(git rev-parse --abbrev-ref HEAD)
release_commit=$(git rev-list --max-count=1 "$TAG")
release_branch="release/$TAG"
if [[ -z $NO_GIT_PUSH ]]; then
  git push --quiet --atomic origin "refs/heads/$local_branch" "refs/tags/$TAG" "$release_commit:refs/heads/$release_branch"
  log "Tag $TAG pushed to origin"
  log "All commit(s) pushed to origin/$local_branch"
  log "Release commit (tagged with $TAG) pushed to origin/$release_branch"
  if [[ -n $QUIET ]]; then
    echo "$release_branch"
  fi
else
  log "You now need to eyeball these commits, then push manually:"
  log
  log "# push local commits and tags to $local_branch"
  log "git push origin refs/heads/$local_branch refs/tags/$TAG"
  log
  log "# push to release branch"
  log "git push origin $release_commit:refs/heads/$release_branch"
  log
  log
  log "If things do not look quite right you can roll back the release:"
  log
  log "# reset to the commit before release started"
  log "git reset --hard $COMMIT_BEFORE_RELEASE"
  log
  log "# delete the git tag that was created"
  log "git tag -d $TAG"
fi
